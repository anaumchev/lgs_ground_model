%%%%%%%%%%%%%%%%%%%%%%% file template.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is a general template file for the LaTeX package SVJour3
% for Springer journals.          Springer Heidelberg 2010/09/16
%
% Copy it to a new file with a new name and use it as the basis
% for your article. Delete % signs as needed.
%
% This template includes a few options for different layouts and
% content for various journals. Please consult a previous issue of
% your journal as needed.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% First comes an example EPS file -- just ignore it and
% proceed on the \documentclass line
% your LaTeX will extract the file if required
\begin{filecontents*}{example.eps}
%!PS-Adobe-3.0 EPSF-3.0
%%BoundingBox: 19 19 221 221
%%CreationDate: Mon Sep 29 1997
%%Creator: programmed by hand (JK)
%%EndComments
gsave
newpath
  20 20 moveto
  20 220 lineto
  220 220 lineto
  220 20 lineto
closepath
2 setlinewidth
gsave
  .4 setgray fill
grestore
stroke
grestore
\end{filecontents*}
%
\RequirePackage{fix-cm}
%
%\documentclass{svjour3}                     % onecolumn (standard format)
%\documentclass[smallcondensed]{svjour3}     % onecolumn (ditto)
\documentclass[smallextended]{svjour3}       % onecolumn (second format)
%\documentclass[twocolumn]{svjour3}          % twocolumn
%
\smartqed  % flush right qed marks, e.g. at end of proof
%
\usepackage{graphicx}
\usepackage{color}

\usepackage{hyperref}
% Configuring autoref, included by hyperref
\def\sectionautorefname{Section}
\def\subsectionautorefname{Section}
\def\subsubsectionautorefname{Section}
\def\figureautorefname{Figure}
\def\tableautorefname{Table}
\def\equationautorefname{Equation}

\newcommand{\e}[1]{\mbox{\lstinline[basicstyle=\normalsize]|#1|}}
\newcommand{\es}[1]{\mbox{\lstinline[basicstyle=\scriptsize]|#1|}}
\newcommand{\et}[1]{\mbox{\lstinline[basicstyle=\tiny]|#1|}}
\newcommand{\etd}[1]{\mbox{\lstinline[basicstyle=\tiny]|#1|}}

\usepackage{listings}
\usepackage{eiffel}
\usepackage{boogie}

\lstset{
	language=OOSC2Eiffel,
	basicstyle=\footnotesize,
    float=*
}

\usepackage{amsmath,amssymb}
\usepackage{wasysym}
%
% \usepackage{mathptmx}      % use Times fonts if available on your TeX system
%
% insert here the call for the packages your document requires
%\usepackage{latexsym}
% etc.
%
% please place your own definitions here and don't use \def but
% \newcommand{}{}
%
% Insert the name of "your journal" with
% \journalname{myjournal}
%
\begin{document}

\title{Encoding temporal properties for a general-purpose program verifier%\thanks{Grants or other notes
%about the article that should go on the front page should be
%placed here. General acknowledgments should be placed at the end of the article.}
}
%\subtitle{Do you have a subtitle?\\ If so, write it here}

%\titlerunning{Short form of title}        % if too long for running head

\author{First Author         \and
        Second Author %etc.
}

%\authorrunning{Short form of author list} % if too long for running head

\institute{F. Author \at
              first address \\
              \email{fauthor@example.com}           %  \\
%             \emph{Present address:} of F. Author  %  if needed
           \and
           S. Author \at
              second address
}

\date{Received: date / Accepted: date}
% The correct dates will be entered by the editor


\maketitle

\begin{abstract}
The verification of many practical systems -- in particular, embedded systems -- involves processes executing over time, for which it is common to use models based on temporal logic, in either its linear (LTL) or branching (CTL). Some of today’s most advanced automatic program verifiers, however, rely on non-temporal theories, particularly Hoare-style logic. Can we still take advantage of this sophisticated verification technology for more challenging systems? \\
...
%As a step towards a positive answer, we have defined a translation scheme from CTL specifications to contract-equipped object-oriented programs, expressed in Eiffel and hence open for processing by the AutoProof program prover. We have applied this scheme to a published CTL model of a widely used realistic example, the “landing gear” system which has been the subject of numerous competing specifications. An attempt to verify the result in AutoProof failed to prove two CTL properties, which on further inspection seemed to be wrong in the original published model, even though the published work claimed to have verified an Abstract State Machine implementation of that model.
%
%Correcting the CTL specification to reflect the apparent informal attempt, re-translating again to contracted Eiffel and re-running the verification leads to success.
%
%The CTL-to-contracted-Eiffel process is still ad hoc, and tailored to generate the kind of scheme that the target verification tool (AutoProof) can handle best, rather than the simplest or most elegant scheme. Even with this limitation, the results highlight the need for rigor in the verification process, and (on the positive side) demonstrate that the highly advanced mechanized proof technology developed over several decades for the verification of traditional programs also has the potential of handling the demanding needs of embedded systems and other demanding contemporary developments.

\keywords{First keyword \and Second keyword \and More}
% \PACS{PACS code1 \and PACS code2 \and more}
% \subclass{MSC code1 \and MSC code2 \and more}
\end{abstract}

\section{Overview and main results}
\label{sec:overview}

\begin{figure}
\begin{lstlisting}
from
until
  False
loop
  main
end
\end{lstlisting}
\caption{The context: an infinitely running process that frequently polls the environment for changes and reacts appropriately.}
\label{fig:inifinitely_running_process}
\end{figure}

\textcolor{red}{Sasha: If you have a question or a comment, please insert it in red.}

\section{CTL specifications and the landing gear example}
\label{sec:landing_gear_example}

\cite{arcaini2014modeling}

\section{AutoProof}
\label{sec:autoproof}

\cite{tschannen2015autoproof}

\section{The translation scheme}
\label{sec:translation_scheme}


\begin{figure}
\begin{tabular}{c c c}
$\Square f$
&
$\Longrightarrow$
&
\begin{lstlisting}
f_holds_globally
  do    
  ensure
    f
  end
\end{lstlisting}
\end{tabular}
\caption{Translation of the ``globally" operator.}
\label{fig:ltl_globally_eiffel}
\end{figure}


\begin{figure}
\begin{tabular}{c c c}
$\Circle f$ 
&
$\Longrightarrow$
&
\begin{lstlisting}
f_holds_next
  do
    main
  ensure
    f
  end
\end{lstlisting}
\end{tabular}
\caption{Translation of the ``next" operator.}
\label{fig:ltl_next_eiffel}
\end{figure}


\begin{figure}
\begin{tabular}{c c c}
$\Diamond[k] f$
&
$\Longrightarrow$
&
\begin{lstlisting}
f_eventually_holds
  local
    steps: INTEGER
  do
    from
      steps := 0
    until
      f or else steps = k
    loop
      main
      steps := steps + 1
    end
  ensure
    f
  end
\end{lstlisting}
\end{tabular}
\caption{Translation of the ``finally" operator.}
\label{fig:ltl_eventually_eiffel}
\end{figure}


\begin{figure}
\begin{tabular}{c c c}
$f \mathcal{U}[k] g$
&
$\Longrightarrow$
&
\begin{lstlisting}
f_holds_until_g
  require
    f
  local
    steps: INTEGER
  do
    from
      steps := 0
    until
      not f or else g or else steps = k
    loop
      main
      steps := steps + 1
    end
  ensure
    g
  end
\end{lstlisting}
\end{tabular}
\caption{Translation of the ``until" operator.}
\label{fig:ltl_until_eiffel}
\end{figure}

\begin{figure}
\begin{tabular}{c c c}
$f \mathcal{R}[k] g$
&
$\Longrightarrow$
&
\begin{lstlisting}
f_releases_g
  require
    g
  local
    steps: INTEGER
  do
    from
      steps := 0
    until
      not g or else f or else steps = k
    loop
      main
      steps := steps + 1
    end
  ensure
    f and g
  end
\end{lstlisting}
\end{tabular}
\caption{Translation of the ``release" operator.}
\label{fig:ltl_release_eiffel}
\end{figure}


\section{Applying the translation scheme to the landing gear example}
\label{sec:applying_to_example}

\begin{figure}
\begin{lstlisting}
r11_bis
  -- If the handle is down and stays down, the doors will close and the gears
  -- extend in not more than MAX_INT runs of the main routine:
  -- (gears=EXTENDED and doors=CLOSED) R[MAX_INT] (handle=DOWN)
  require
    is_consistent  
  	handle_status = is_handle_down
  local
    steps: INTEGER
  do
    from
      steps := 0
    until
      (not is_consistent) or else
      (handle_status /= is_handle_down) or else
      (door_status = is_door_closed and gear_status = is_gear_extended) or else
      (steps = steps.max_value)
    loop
      main
      steps := steps + 1
    end
  ensure
  	is_consistent  
    handle_status = is_handle_down
    gear_status = is_gear_extended
    door_status = is_door_closed
  end
\end{lstlisting}
\caption{Translation of the ``r11\_bis" requirement.}
\label{fig:r11_bis_translation}
\end{figure}


\begin{figure}
\begin{lstlisting}
r12_bis
  -- If the handle is up and stays up, the doors will close and the gears
  -- retract in not more than MAX_INT runs of the main routine:
  -- (gears=RETRACTED and doors=CLOSED) R[MAX_INT] (handle=UP)
  require
    is_consistent
  	is_handle_status = is_handle_up
  local
    steps: INTEGER
  do
    from
      steps := 0
    until
      (not is_consistent) or else
      (handle_status /= is_handle_up) or else
      (door_status = is_door_closed and gear_status = is_gear_retracted) or else
      (steps = steps.max_value)
    loop
      main
      steps := steps + 1
    end
  ensure
  	is_consistent
    handle_status = is_handle_up
    gear_status = is_gear_retracted
    door_status = is_door_closed
  end

\end{lstlisting}
\caption{Translation of the ``r12\_bis" requirement.}
\label{fig:r12_bis_translation}
\end{figure}


\begin{figure}
\begin{lstlisting}
r21
    -- If the handle is down, then in the next state
    -- the gears will not be retracting:
    -- handle = DOWN implies O(gears != RETRACTING)
  require
    handle_status = is_handle_down
    is_consistent
  do
    main
  ensure
    gear_status /= is_gear_retracting
  end
\end{lstlisting}
\caption{Translation of the ``r21" requirement.}
\label{fig:r21_translation}
\end{figure}

\begin{figure}
\begin{lstlisting}
r22
    -- If the handle is up, then in the next state
    -- the gears will not be extending:
    -- handle = UP implies O(gears != EXTENDING)
  require
    handle_status = is_handle_up
    is_consistent
  do
    main
  ensure
    gear_status /= is_gear_extending
  end
\end{lstlisting}
\caption{Translation of the ``r21" requirement.}
\label{fig:r22_translation}
\end{figure}


\section{Limitations of the translation scheme and AutoProof}
\label{sec:limitations}



\section{Conclusions and future work}
\label{sec:conclusions}
%\begin{acknowledgements}
%If you'd like to thank anyone, place your comments here
%and remove the percent signs.
%\end{acknowledgements}

% BibTeX users please use one of
%\bibliographystyle{spbasic}      % basic style, author-year citations
%\bibliographystyle{spmpsci}      % mathematics and physical sciences
%\bibliographystyle{spphys}       % APS-like style for physics
%\bibliography{}   % name your BibTeX data base

% Non-BibTeX users please use
{{{
	\bibliographystyle{spbasic}
	\bibliography{EncodingCTL}
}}}
\end{document}
% end of file template.tex

